use sqs_executor::event_decoder::PayloadDecoder;
use std::io::Cursor;

/// A [PayloadDecoder] used to decompress zstd encoded events sent to an [EventHandler].
///
/// This `struct` is typically used in conjunction with a subsequent call to [run_graph_generator].
#[derive(Debug, Clone, Default)]
pub struct ZstdDecoder;

impl PayloadDecoder<Vec<u8>> for ZstdDecoder {
    fn decode(&mut self, body: Vec<u8>) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let mut decompressed = Vec::with_capacity(body.len());
        let mut body = Cursor::new(&body);

        zstd::stream::copy_decode(&mut body, &mut decompressed)?;

        Ok(decompressed)
    }
}



use grapl_graph_descriptions::graph_description::*;
use log::*;
use sqs_executor::completion_event_serializer::CompletionEventSerializer;
use prost::EncodeError;

/// Takes a subgraph generated by a Generator and serializes it so it can be returned by a
/// lambda as an execution result.
#[derive(Clone, Debug, Default)]
pub struct SubgraphSerializer {
    proto: Vec<u8>,
}

impl SubgraphSerializer {
    pub fn new(proto: Vec<u8>) -> Self {
        Self { proto }
    }
}

#[derive(thiserror::Error, Debug)]
pub enum SubgraphSerializerError {
    #[error("IO")]
    Io(#[from] std::io::Error),
    #[error("EncodeError")]
    EncodeError(#[from] EncodeError),
}

impl CompletionEventSerializer for SubgraphSerializer {
    type CompletedEvent = Graph;
    type Output = Vec<u8>;
    type Error = SubgraphSerializerError;

    fn serialize_completed_events(
        &mut self,
        completed_events: &[Self::CompletedEvent],
    ) -> Result<Vec<Self::Output>, Self::Error> {
        let mut subgraph = Graph::new(0);

        // counts nodes and edges before subgraphs are merged
        let mut pre_nodes = 0;
        let mut pre_edges = 0;

        for sg in completed_events.iter() {
            pre_nodes += sg.nodes.len();
            pre_edges += sg.edges.len();
            subgraph.merge(sg);
        }

        if subgraph.is_empty() {
            debug!(
                concat!(
                "Output subgraph is empty. Serializing to empty vector.",
                "pre_nodes: {} pre_edges: {}"
                ),
                pre_nodes, pre_edges,
            );
            return Ok(vec![]);
        }

        // TODO: This should be a monitor
        debug!(
            "Serializing {} nodes {} edges. Down from {} nodes {} edges.",
            subgraph.nodes.len(),
            subgraph.edges.len(),
            pre_nodes,
            pre_edges,
        );

        let subgraphs = GeneratedSubgraphs {
            subgraphs: vec![subgraph],
        };

        self.proto.clear();

        // encode generated subgraphs into protocol buffer
        prost::Message::encode(&subgraphs, &mut self.proto)?;

        let mut compressed = Vec::with_capacity(self.proto.len());
        let mut proto = Cursor::new(&self.proto);

        // compress encoded subgraph into `compressed` vector
        zstd::stream::copy_encode(&mut proto, &mut compressed, 4)?;

        Ok(vec![compressed])
    }
}